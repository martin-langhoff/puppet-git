#!/bin/bash

if [[ -n "${PPG_DEBUG}" ]]; then
	set -x
fi

hostnametoint() {
    # read the md5 as a sequence of unsigned ints
    ints=$(hostname -s | openssl dgst -md5 -binary | od -d -N32 -w32 | head -n1 | cut -f2- -d' ')

    sum=0
    for val in $ints; do
        sum=$(( $sum + $val ))
    done
    echo $sum
}

pushd /etc/puppet >/dev/null || exit 1

PPG_EXEC_PATH=$( dirname $(readlink -f "${BASH_SOURCE[0]}" ) )
GIT_EXEC_PATH=$(git --exec-path)
GIT_DIR=$(git rev-parse --git-dir)
GIT_SSH="${PPG_EXEC_PATH}/ppg-ssh"

if [ -z "$GIT_DIR" ]; then
	echo >&2 "Not in a git checkout"
	exit 1
fi

headname=$(git rev-parse --symbolic-full-name --revs-only HEAD)

if [[ "$headname" != "refs/heads/production" ]]; then
	echo >&2 "WARNING: Not on production branch"
fi

initial_sha1=$(git rev-parse --revs-only HEAD)
lastgood_sha1=$(git rev-parse --revs-only refs/heads/ppg/lastgood)

# resilient wrt server availability...
git fetch || echo "WARNING: error in git fetch"

if [[ "$headname" = "refs/heads/production" ]]; then
	$PPG_EXEC_PATH/ppg-update-production || exit 1
else
	if ! git pull --ff-only ; then
		echo "ERROR: Failed to auto-merge with ff-only,"
		echo "       perhaps the current branch needs to"
		echo "       track a remote branch or you have dirty state."
		echo "       You can merge by hand and use ppg-apply"
	fi
fi

uptodate_sha1=$(git rev-parse --revs-only HEAD)

echo "Executing command"
echo
echo "  "ppg-apply "$@"
echo
echo "Log of changes to apply" 
echo
if [ -n "$lastgood_sha1" ]; then
	if [[ "$uptodate_sha1" != "$lastgood_sha1" ]]; then
		git log --oneline ${lastgood_sha1}..${uptodate_sha1}
	else
		echo "No changes in git"
		this_hour=$(date +%H)
		unconditional_hour=$(( $(hostnametoint) % 24 ))
		# lazy 23 times a day
		if [ ${this_hour} -ne ${unconditional_hour} ]; then
			exec $PPG_EXEC_PATH/ppg-push-empty-report
		fi
	fi
else
	git log --oneline ${uptodate_sha1}
fi
echo
exec $PPG_EXEC_PATH/ppg-apply "$@"
